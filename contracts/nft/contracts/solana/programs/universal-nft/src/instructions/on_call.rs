use anchor_lang::prelude::*;
use anchor_spl::{
    associated_token::AssociatedToken,
    token::{mint_to, Mint, MintTo, Token, TokenAccount},
};
use solana_program::{
    sysvar::{self, clock::Clock, rent::Rent},
    program::invoke_signed,
};
use crate::state::{Collection, NftOrigin, CrossChainMessage, validate_solana_address};
use crate::{
    UniversalNftError, TOKEN_METADATA_PROGRAM_ID, ZETACHAIN_GATEWAY_PROGRAM_ID,
    find_nft_origin_pda,
};

// Import Metaplex types from mpl-token-metadata crate
use mpl_token_metadata::{
    types::{DataV2},
    instructions,
};
use crate::utils::is_supported_chain;

// Helper trait for account discriminators
trait AccountDiscriminator {
    fn discriminator() -> [u8; 8];
}

impl AccountDiscriminator for NftOrigin {
    fn discriminator() -> [u8; 8] {
        // This would typically be generated by Anchor
        // For now, using a simple hash of the struct name
        use anchor_lang::solana_program::keccak;
        let hash = keccak::hash(b"account:NftOrigin");
        [
            hash.0[0], hash.0[1], hash.0[2], hash.0[3],
            hash.0[4], hash.0[5], hash.0[6], hash.0[7],
        ]
    }
}

/// Handle incoming cross-chain NFT transfer with two-scenario NFT Origin system
pub fn on_call(
    ctx: Context<OnCall>,
    sender: Vec<u8>,
    source_chain_id: u64,
    message: Vec<u8>,
    nonce: u64,
) -> Result<()> {
    let _collection_key = ctx.accounts.collection.key();

    // Enhanced gateway authorization using Instructions sysvar
    let instructions = ctx.accounts.instructions.to_account_info();
    let current_index = sysvar::instructions::load_current_index_checked(&instructions)?;

    // Verify the previous instruction was from the gateway program
    if current_index > 0 {
        let previous_instruction = sysvar::instructions::load_instruction_at_checked(
            (current_index - 1) as usize,
            &instructions,
        )?;
        require!(
            previous_instruction.program_id == ZETACHAIN_GATEWAY_PROGRAM_ID,
            UniversalNftError::UnauthorizedGateway
        );
    }

    // Additional PDA verification for gateway account
    let collection_key_bytes = ctx.accounts.collection.key().to_bytes();
    let gateway_seeds = &[b"gateway", &collection_key_bytes[..]];
    let (expected_gateway_pda, _) = Pubkey::find_program_address(gateway_seeds, &ZETACHAIN_GATEWAY_PROGRAM_ID);
    require!(
        ctx.accounts.gateway.key() == expected_gateway_pda,
        UniversalNftError::UnauthorizedGateway
    );

    // Enhanced replay protection - check nonce with proper validation
    require!(
        nonce > ctx.accounts.collection.nonce,
        UniversalNftError::InvalidNonce
    );

    // Additional nonce validation to prevent overflow attacks
    require!(
        nonce <= ctx.accounts.collection.nonce.saturating_add(1000000),
        UniversalNftError::InvalidNonce
    );

    // Parse the cross-chain message to extract NFT data
    let (token_id, uri, recipient_pubkey, origin_chain) = parse_cross_chain_message(&message, source_chain_id)?;

    // Enhanced recipient validation
    require_keys_eq!(
        recipient_pubkey,
        ctx.accounts.recipient.key(),
        UniversalNftError::InvalidRecipient
    );

    // Validate URI format and length
    require!(
        !uri.is_empty() && uri.len() <= 200,
        UniversalNftError::InvalidMessage
    );

    // Parse token_id from message first to derive the PDA
    let token_id_for_pda = extract_token_id_from_message(&message)?;

    // Validate token ID consistency
    require_eq!(
        token_id,
        token_id_for_pda,
        UniversalNftError::InvalidTokenId
    );

    // Derive the NFT Origin PDA with enhanced validation
    let (nft_origin_pda, nft_origin_bump) = find_nft_origin_pda(
        &crate::ID,
        token_id_for_pda,
    );

    // Verify the provided NFT Origin account matches the expected PDA
    require_keys_eq!(
        nft_origin_pda,
        ctx.accounts.nft_origin.key(),
        UniversalNftError::InvalidMessage
    );

    // Enhanced NFT Origin existence check with proper account validation
    let nft_origin_exists = !ctx.accounts.nft_origin.data_is_empty() &&
                           ctx.accounts.nft_origin.owner == &crate::ID;

    if nft_origin_exists {
        // Scenario A: NFT was previously on Solana - returning NFT
        handle_returning_nft(
            &ctx,
            token_id,
            &uri,
            origin_chain,
            &sender,
            nonce,
            nft_origin_bump,
        )?;
    } else {
        // Scenario B: First time on Solana - new NFT
        handle_new_nft_arrival(
            &ctx,
            token_id,
            &uri,
            origin_chain,
            &sender,
            nonce,
            nft_origin_bump,
        )?;
    }

    // Update collection nonce to prevent replay
    let collection = &mut ctx.accounts.collection;
    collection.nonce = nonce;

    Ok(())
}

/// Handle Scenario A: NFT returning to Solana (origin PDA exists)
fn handle_returning_nft(
    ctx: &Context<OnCall>,
    token_id: u64,
    uri: &str,
    origin_chain: u64,
    sender: &Vec<u8>,
    nonce: u64,
    _nft_origin_bump: u8,
) -> Result<()> {
    // Load and deserialize the existing NFT Origin account with enhanced validation
    let nft_origin_data = ctx.accounts.nft_origin.try_borrow_data()
        .map_err(|_| UniversalNftError::InvalidMessage)?;

    // Validate account data length before deserialization
    require!(
        nft_origin_data.len() >= 8 + NftOrigin::INIT_SPACE,
        UniversalNftError::InvalidMessage
    );

    // Skip 8-byte Anchor discriminator and deserialize the actual data
    let nft_origin = NftOrigin::try_from_slice(&nft_origin_data[8..])
        .map_err(|_| UniversalNftError::InvalidMessage)?;

    let collection = &ctx.accounts.collection;

    // Enhanced validation for the origin PDA
    nft_origin.validate_token_id(token_id)?;

    // Validate collection reference
    require_keys_eq!(
        nft_origin.collection,
        collection.key(),
        UniversalNftError::InvalidMessage
    );

    // Preserve original metadata URI with validation, otherwise use new URI
    let metadata_uri = if !nft_origin.metadata_uri.is_empty() &&
                          nft_origin.metadata_uri.len() <= 200 {
        nft_origin.metadata_uri.clone()
    } else {
        uri.to_string()
    };

    // Store the original mint for the event
    let original_mint = nft_origin.original_mint;

    // Create new mint for the returning NFT with enhanced metadata
    mint_nft_with_metadata(
        ctx,
        &metadata_uri,
        format!("Universal NFT #{}", token_id),
        collection.symbol.clone(),
        Some(original_mint), // Pass original mint for reference
    )?;

    // Emit event for returning NFT
    emit!(crate::NftReturningToSolana {
        token_id,
        original_mint,
        new_mint: ctx.accounts.nft_mint.key(),
        collection: collection.key(),
        metadata_preserved: !metadata_uri.is_empty(),
        return_chain: origin_chain,
        cycle_count: 1,
        timestamp: Clock::get()?.unix_timestamp,
    });

    emit!(crate::TokenTransferReceived {
        collection: collection.key(),
        token_id,
        recipient: ctx.accounts.recipient.key(),
        uri: metadata_uri,
        original_sender: sender.to_vec(),
        nonce,
        origin_chain,
        original_mint: Some(original_mint),
        is_returning: true,
        metadata_preserved: true,
        timestamp: Clock::get()?.unix_timestamp,
    });

    Ok(())
}

/// Handle Scenario B: NFT arriving on Solana for the first time
fn handle_new_nft_arrival(
    ctx: &Context<OnCall>,
    token_id: u64,
    uri: &str,
    origin_chain: u64,
    sender: &Vec<u8>,
    nonce: u64,
    nft_origin_bump: u8,
) -> Result<()> {
    let collection = &ctx.accounts.collection;
    let clock = Clock::get()?;

    // Validate that the NFT Origin account is indeed uninitialized
    require!(
        ctx.accounts.nft_origin.data_is_empty() || ctx.accounts.nft_origin.owner != &crate::ID,
        UniversalNftError::InvalidMessage
    );

    // Enhanced NFT Origin account creation with proper rent calculation
    let rent = Rent::get()?;
    let space = 8 + NftOrigin::INIT_SPACE; // Account discriminator + data
    let lamports = rent.minimum_balance(space);

    // Validate sufficient funds for account creation
    require!(
        ctx.accounts.payer.lamports() >= lamports,
        UniversalNftError::InsufficientGasAmount
    );

    // Create the NFT Origin account with enhanced error handling
    anchor_lang::solana_program::program::invoke_signed(
        &anchor_lang::solana_program::system_instruction::create_account(
            ctx.accounts.payer.key,
            ctx.accounts.nft_origin.key,
            lamports,
            space as u64,
            &crate::ID,
        ),
        &[
            ctx.accounts.payer.to_account_info(),
            ctx.accounts.nft_origin.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
        ],
        &[&[
            b"nft_origin",
            &token_id.to_le_bytes(),
            &[nft_origin_bump],
        ]],
    ).map_err(|_| UniversalNftError::InvalidMessage)?;

    // Initialize new NFT Origin data with enhanced validation
    let nft_origin = NftOrigin {
        original_mint: ctx.accounts.nft_mint.key(), // This will be the first mint on Solana
        token_id,
        collection: collection.key(),
        chain_of_origin: origin_chain,
        created_at: clock.unix_timestamp,
        metadata_uri: uri.to_string(),
        bump: nft_origin_bump,
    };

    // Serialize and save the NFT Origin data with proper error handling
    let mut nft_origin_data = ctx.accounts.nft_origin.try_borrow_mut_data()
        .map_err(|_| UniversalNftError::InvalidMessage)?;

    // Use Anchor's proper account serialization
        let mut data = ctx.accounts.nft_origin.try_borrow_mut_data()
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    let mut cursor: &mut [u8] = &mut data;
    // Write discriminator then serialize
    cursor[0..8].copy_from_slice(&<NftOrigin as anchor_lang::Discriminator>::discriminator());
    let mut payload = &mut cursor[8..];
    anchor_lang::AnchorSerialize::serialize(&nft_origin, &mut payload)
        .map_err(|_| UniversalNftError::InvalidMessage)?;

    // Create mint and metadata for the new NFT
    mint_nft_with_metadata(
        ctx,
        uri,
        format!("Universal NFT #{}", token_id),
        collection.symbol.clone(),
        None, // No original mint for new arrivals
    )?;

    // Emit events for new NFT origin creation
    emit!(crate::NftOriginCreated {
        token_id,
        original_mint: ctx.accounts.nft_mint.key(),
        collection: collection.key(),
        origin_chain,
        metadata_uri: uri.to_string(),
        created_at: Clock::get()?.unix_timestamp,
        bump: nft_origin_bump,
    });

    emit!(crate::TokenTransferReceived {
        collection: collection.key(),
        token_id,
        recipient: ctx.accounts.recipient.key(),
        uri: uri.to_string(),
        original_sender: sender.to_vec(),
        nonce,
        origin_chain,
        original_mint: Some(ctx.accounts.nft_mint.key()),
        is_returning: false,
        metadata_preserved: true,
        timestamp: Clock::get()?.unix_timestamp,
    });

    Ok(())
}

/// Mint NFT with proper Metaplex metadata
fn mint_nft_with_metadata(
    ctx: &Context<OnCall>,
    uri: &str,
    name: String,
    symbol: String,
    original_mint: Option<Pubkey>,
) -> Result<()> {
    let collection = &ctx.accounts.collection;

    // Extract values before mutable borrow
    let collection_authority = collection.authority;
    let collection_name = collection.name.clone();
    let collection_bump = collection.bump;

    // Enhanced validation for metadata parameters
    require!(
        !name.is_empty() && name.len() <= 32,
        UniversalNftError::InvalidMessage
    );
    require!(
        !symbol.is_empty() && symbol.len() <= 10,
        UniversalNftError::InvalidMessage
    );
    require!(
        !uri.is_empty() && uri.len() <= 200,
        UniversalNftError::InvalidMessage
    );

    // Mint the NFT token with enhanced error handling
    let cpi_ctx = CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        MintTo {
            mint: ctx.accounts.nft_mint.to_account_info(),
            to: ctx.accounts.nft_token_account.to_account_info(),
            authority: ctx.accounts.collection.to_account_info(),
        },
    );

    let seeds = &[
        b"collection",
        collection_authority.as_ref(),
        collection_name.as_bytes(),
        &[collection_bump],
    ];
    let signer_seeds = &[&seeds[..]];

    mint_to(cpi_ctx.with_signer(signer_seeds), 1)
        .map_err(|_| UniversalNftError::InvalidMessage)?;

    // Create Metaplex metadata with proper CPI calls
    create_metadata_account_v3(
        ctx,
        &name,
        &symbol,
        uri,
        original_mint,
        signer_seeds,
    )?;

    Ok(())
}

/// Create Metaplex metadata account using proper CPI calls
fn create_metadata_account_v3(
    ctx: &Context<OnCall>,
    name: &str,
    symbol: &str,
    uri: &str,
    original_mint: Option<Pubkey>,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    // Prepare DataV2 struct for proper Metaplex CPI
    let data_v2 = DataV2 {
        name: name.to_string(),
        symbol: symbol.to_string(),
        uri: uri.to_string(),
        seller_fee_basis_points: 0, // No royalties for cross-chain NFTs
        creators: None, // No specific creators for universal NFTs
        collection: None, // Collection verification handled separately
        uses: None, // No usage restrictions
    };

    // Create the metadata account using proper Metaplex instruction
    let create_metadata_instruction = instructions::CreateMetadataAccountV3 {
        metadata: ctx.accounts.nft_metadata.key(),
        mint: ctx.accounts.nft_mint.key(),
        mint_authority: ctx.accounts.collection.key(),
        payer: ctx.accounts.payer.key(),
        update_authority: (ctx.accounts.collection.key(), true),
        system_program: anchor_lang::solana_program::system_program::ID,
        rent: Some(sysvar::rent::ID),
    };
    
    // Execute the CPI call with proper error handling
    invoke_signed(
        &create_metadata_instruction.instruction(
            instructions::CreateMetadataAccountV3InstructionArgs {
                data: data_v2,
                is_mutable: true,
                collection_details: None,
            }
        ),
        &[
            ctx.accounts.nft_metadata.to_account_info(),
            ctx.accounts.nft_mint.to_account_info(),
            ctx.accounts.collection.to_account_info(),
            ctx.accounts.payer.to_account_info(),
            ctx.accounts.collection.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
        ],
        signer_seeds,
    ).map_err(|e| {
        msg!("Failed to create metadata account: {:?}", e);
        UniversalNftError::InvalidMessage
    })?;
    
    // If this is a returning NFT, add a note about the original mint
    if let Some(orig_mint) = original_mint {
        msg!("NFT returning to Solana. Original mint: {}", orig_mint);
    }
    
    Ok(())
}


/// Parse cross-chain message to extract NFT data and origin information
fn parse_cross_chain_message(
    message: &[u8],
    source_chain_id: u64,
) -> Result<(u64, String, Pubkey, u64)> {
    // Try to decode as Borsh first (Solana native)
    if let Ok((token_id, uri, recipient)) = try_decode_borsh_message(message) {
        return Ok((token_id, uri, recipient, source_chain_id));
    }
    
    // Try to decode as ABI (EVM chains)
    if let Ok((token_id, uri, recipient)) = try_decode_abi_message(message) {
        return Ok((token_id, uri, recipient, source_chain_id));
    }
    
    // Try enhanced message format with origin information
    if let Ok((token_id, uri, recipient, origin_chain)) = try_decode_enhanced_message(message) {
        return Ok((token_id, uri, recipient, origin_chain));
    }
    
    Err(UniversalNftError::InvalidMessage.into())
}

/// Try to decode enhanced message format with origin information
fn try_decode_enhanced_message(message: &[u8]) -> Result<(u64, String, Pubkey, u64)> {
    // Enhanced format: [token_id(8), origin_chain(8), uri_len(4), uri(variable), recipient(32)]
    require!(message.len() >= 52, UniversalNftError::InvalidMessage);
    
    let mut offset = 0;
    
    // Extract token_id with validation
    let token_id = u64::from_le_bytes(
        message[offset..offset + 8]
            .try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    );
    
    // Validate token_id is not zero
    require!(token_id > 0, UniversalNftError::InvalidTokenId);
    offset += 8;
    
    // Extract origin_chain with validation
    let origin_chain = u64::from_le_bytes(
        message[offset..offset + 8]
            .try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    );
    
    // Validate origin chain is supported
    require!(
        is_supported_chain(origin_chain),
        UniversalNftError::UnsupportedChain
    );
    offset += 8;
    
    // Extract URI length with bounds checking
    let uri_len = u32::from_le_bytes(
        message[offset..offset + 4]
            .try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    ) as usize;
    
    // Validate URI length is reasonable
    require!(
        uri_len > 0 && uri_len <= 200,
        UniversalNftError::InvalidMessage
    );
    offset += 4;
    
    // Validate total message length
    require!(
        message.len() >= offset + uri_len + 32,
        UniversalNftError::InvalidMessage
    );
    
    // Extract and validate URI
    let uri = String::from_utf8(message[offset..offset + uri_len].to_vec())
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Validate URI is not empty and contains valid characters
    require!(
        !uri.is_empty() && uri.chars().all(|c| c.is_ascii() && !c.is_control()),
        UniversalNftError::InvalidMessage
    );
    offset += uri_len;
    
    // Extract recipient (32 bytes for Solana pubkey)
    let recipient_bytes: [u8; 32] = message[offset..offset + 32]
        .try_into()
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    let recipient_pubkey = Pubkey::new_from_array(recipient_bytes);
    
    // Validate recipient is not the default pubkey
    require!(
        recipient_pubkey != Pubkey::default(),
        UniversalNftError::InvalidRecipientAddress
    );
    
    Ok((token_id, uri, recipient_pubkey, origin_chain))
}

/// Try to decode ABI-encoded message from EVM chains
fn try_decode_abi_message(message: &[u8]) -> Result<(u64, String, Pubkey)> {
    // Decode proper Ethereum ABI format to match gateway.rs encode_abi()
    // Expected format: 4-byte selector + ABI-encoded parameters with 32-byte alignment
    require!(message.len() >= 4 + 32 * 9, UniversalNftError::InvalidMessage); // selector + 9 parameters
    
    let mut offset = 4; // Skip function selector
    
    // 1. token_id (uint256) - 32 bytes, big-endian, right-aligned
    let mut token_id_bytes = [0u8; 8];
    token_id_bytes.copy_from_slice(&message[offset + 24..offset + 32]);
    let token_id = u64::from_be_bytes(token_id_bytes);
    require!(token_id > 0, UniversalNftError::InvalidTokenId);
    offset += 32;
    
    // 2. recipient (address) - 32 bytes, left-padded, extract 20 bytes
    let recipient_bytes = &message[offset + 12..offset + 32];
    let recipient = Pubkey::new_from_array(
        recipient_bytes.try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    );
    offset += 32;
    
    // 3. uri offset (uint256) - 32 bytes, points to dynamic data
    let uri_offset = u32::from_be_bytes([
        message[offset + 28], message[offset + 29], 
        message[offset + 30], message[offset + 31]
    ]) as usize;
    offset += 32;
    
    // Skip remaining static parameters (sender, origin_chain, original_mint, is_solana_native, metadata_hash, collection_address)
    offset += 32 * 6;
    
    // Extract URI from dynamic data section
    let uri_start = 4 + uri_offset; // selector + offset
    require!(uri_start + 32 <= message.len(), UniversalNftError::InvalidMessage);
    
    let uri_len = u32::from_be_bytes([
        message[uri_start + 28], message[uri_start + 29],
        message[uri_start + 30], message[uri_start + 31]
    ]) as usize;
    
    // Validate URI length is reasonable
    require!(
        uri_len > 0 && uri_len <= 200,
        UniversalNftError::InvalidMessage
    );
    
    // Extract URI string data with proper padding handling
    let uri_data_start = uri_start + 32; // Skip length field
    require!(uri_data_start + uri_len <= message.len(), UniversalNftError::InvalidMessage);
    
    let uri = String::from_utf8(message[uri_data_start..uri_data_start + uri_len].to_vec())
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Validate URI format
    require!(
        !uri.is_empty() && uri.len() <= 200,
        UniversalNftError::InvalidMessage
    );
    
    Ok((token_id, uri, recipient))
}

/// Try to decode Borsh-encoded message (Solana native)
fn try_decode_borsh_message(message: &[u8]) -> Result<(u64, String, Pubkey)> {
    // Enhanced Borsh decoding with validation
    require!(message.len() >= 16, UniversalNftError::InvalidMessage); // Minimum size check
    
    let cross_chain_message = CrossChainMessage::try_from_slice(message)
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Validate token_id
    require!(
        cross_chain_message.token_id > 0,
        UniversalNftError::InvalidTokenId
    );
    
    // Validate URI
    require!(
        !cross_chain_message.uri.is_empty() && cross_chain_message.uri.len() <= 200,
        UniversalNftError::InvalidMessage
    );
    
    // Validate and convert recipient address
    let recipient_pubkey = validate_solana_address(&cross_chain_message.recipient)?;
    
    // Additional validation for recipient
    require!(
        recipient_pubkey != Pubkey::default(),
        UniversalNftError::InvalidRecipientAddress
    );
    
    Ok((cross_chain_message.token_id, cross_chain_message.uri, recipient_pubkey))
}

/// Helper function to extract token ID from message for PDA derivation
fn extract_token_id_from_message(message: &[u8]) -> Result<u64> {
    // Enhanced validation for token ID extraction
    require!(message.len() >= 8, UniversalNftError::InvalidMessage);
    
    // Token ID is always the first 8 bytes in all message formats
    let token_id = u64::from_le_bytes(
        message[0..8]
            .try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    );
    
    // Validate token ID is not zero
    require!(token_id > 0, UniversalNftError::InvalidTokenId);
    
    // Validate token ID is within reasonable bounds (prevent overflow attacks)
    require!(
        token_id <= u64::MAX / 2, // Reasonable upper bound
        UniversalNftError::InvalidTokenId
    );
    
    Ok(token_id)
}


#[derive(Accounts)]
#[instruction(token_id: u64)]
pub struct OnCall<'info> {
    #[account(
        mut,
        seeds = [b"collection", collection.authority.as_ref(), collection.name.as_bytes()],
        bump
    )]
    pub collection: Account<'info, Collection>,
    
    pub collection_mint: Account<'info, Mint>,
    
    /// CHECK: Gateway program that calls this function
    #[account(address = ZETACHAIN_GATEWAY_PROGRAM_ID)]
    pub gateway: UncheckedAccount<'info>,
    
    /// Gateway PDA account - must be signer for security
    #[account(mut, signer)]
    pub gateway_pda: UncheckedAccount<'info>,
    
    /// CHECK: NFT Origin PDA - validated in instruction
    #[account(
        mut,
        constraint = nft_origin.owner == &crate::ID || nft_origin.data_is_empty(),
        constraint = nft_origin.to_account_info().data.borrow().len() == 0 || 
                    nft_origin.to_account_info().data.borrow()[0..8] == NftOrigin::discriminator()
    )]
    pub nft_origin: UncheckedAccount<'info>,
    
    #[account(
        init,
        payer = payer,
        mint::decimals = 0,
        mint::authority = collection,
        mint::freeze_authority = collection,
    )]
    pub nft_mint: Account<'info, Mint>,
    
    #[account(
        init,
        payer = payer,
        associated_token::mint = nft_mint,
        associated_token::authority = recipient,
    )]
    pub nft_token_account: Account<'info, TokenAccount>,
    
    /// CHECK: NFT recipient account - validated in instruction
    pub recipient: UncheckedAccount<'info>,
    
    /// CHECK: Metadata account for the NFT - derived from mint
    #[account(mut)]
    pub nft_metadata: UncheckedAccount<'info>,
    
    #[account(mut)]
    pub payer: Signer<'info>,
    
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    /// CHECK: mpl-token-metadata program
    #[account(address = TOKEN_METADATA_PROGRAM_ID)]
    pub metadata_program: UncheckedAccount<'info>,
    /// CHECK: Instructions sysvar for CPI caller verification
    #[account(address = sysvar::instructions::ID)]
    pub instructions: UncheckedAccount<'info>,
}

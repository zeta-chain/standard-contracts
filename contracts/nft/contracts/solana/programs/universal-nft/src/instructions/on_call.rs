use anchor_lang::prelude::*;
use anchor_lang::solana_program::{
    clock::Clock,
    program::invoke_signed,
};
use anchor_spl::{
    associated_token::AssociatedToken,
    token::{mint_to, Mint, MintTo, Token, TokenAccount},
};

use crate::state::{Collection, NftOrigin, CrossChainMessage, validate_solana_address};
use crate::{
    UniversalNftError, TOKEN_METADATA_PROGRAM_ID, ZETACHAIN_GATEWAY_PROGRAM_ID,
    find_nft_origin_pda,
};

// Import Metaplex types for proper CPI calls
// Note: These would be imported from mpl-token-metadata crate in production
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct DataV2 {
    pub name: String,
    pub symbol: String,
    pub uri: String,
    pub seller_fee_basis_points: u16,
    pub creators: Option<Vec<Creator>>,
    pub collection: Option<Collection>,
    pub uses: Option<Uses>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct Creator {
    pub address: Pubkey,
    pub verified: bool,
    pub share: u8,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct Collection {
    pub verified: bool,
    pub key: Pubkey,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct Uses {
    pub use_method: UseMethod,
    pub remaining: u64,
    pub total: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum UseMethod {
    Burn,
    Multiple,
    Single,
}

// Helper trait for account discriminators
trait AccountDiscriminator {
    fn discriminator() -> [u8; 8];
}

impl AccountDiscriminator for NftOrigin {
    fn discriminator() -> [u8; 8] {
        // This would typically be generated by Anchor
        // For now, using a simple hash of the struct name
        use anchor_lang::solana_program::keccak;
        let hash = keccak::hash(b"account:NftOrigin");
        [
            hash.0[0], hash.0[1], hash.0[2], hash.0[3],
            hash.0[4], hash.0[5], hash.0[6], hash.0[7],
        ]
    }
}

/// Handle incoming cross-chain NFT transfer with two-scenario NFT Origin system
pub fn on_call(
    ctx: Context<OnCall>,
    sender: [u8; 20],
    source_chain_id: u64,
    message: Vec<u8>,
    nonce: u64,
) -> Result<()> {
    let _collection_key = ctx.accounts.collection.key();
    
    // Verify the caller is the gateway program
    require!(
        ctx.accounts.gateway.key() == ZETACHAIN_GATEWAY_PROGRAM_ID,
        UniversalNftError::UnauthorizedGateway
    );
    
    // Enhanced replay protection - check nonce with proper validation
    require!(
        nonce > ctx.accounts.collection.nonce,
        UniversalNftError::InvalidNonce
    );
    
    // Additional nonce validation to prevent overflow attacks
    require!(
        nonce <= ctx.accounts.collection.nonce.saturating_add(1000000),
        UniversalNftError::InvalidNonce
    );
    
    // Parse the cross-chain message to extract NFT data
    let (token_id, uri, recipient_pubkey, origin_chain) = parse_cross_chain_message(&message, source_chain_id)?;
    
    // Enhanced recipient validation
    require_keys_eq!(
        recipient_pubkey,
        ctx.accounts.recipient.key(),
        UniversalNftError::InvalidRecipient
    );
    
    // Validate URI format and length
    require!(
        !uri.is_empty() && uri.len() <= 200,
        UniversalNftError::InvalidMessage
    );
    
    // Parse token_id from message first to derive the PDA
    let token_id_for_pda = extract_token_id_from_message(&message)?;
    
    // Validate token ID consistency
    require_eq!(
        token_id,
        token_id_for_pda,
        UniversalNftError::InvalidTokenId
    );
    
    // Derive the NFT Origin PDA with enhanced validation
    let (nft_origin_pda, nft_origin_bump) = find_nft_origin_pda(
        &crate::ID,
        token_id_for_pda,
    );
    
    // Verify the provided NFT Origin account matches the expected PDA
    require_keys_eq!(
        nft_origin_pda,
        ctx.accounts.nft_origin.key(),
        UniversalNftError::InvalidMessage
    );
    
    // Enhanced NFT Origin existence check with proper account validation
    let nft_origin_exists = !ctx.accounts.nft_origin.data_is_empty() && 
                           ctx.accounts.nft_origin.owner == &crate::ID;
    
    if nft_origin_exists {
        // Scenario A: NFT was previously on Solana - returning NFT
        handle_returning_nft(
            &ctx,
            token_id,
            &uri,
            origin_chain,
            &sender,
            nonce,
            nft_origin_bump,
        )?;
    } else {
        // Scenario B: First time on Solana - new NFT
        handle_new_nft_arrival(
            &ctx,
            token_id,
            &uri,
            origin_chain,
            &sender,
            nonce,
            nft_origin_bump,
        )?;
    }
    
    // Update collection nonce to prevent replay
    let collection = &mut ctx.accounts.collection;
    collection.nonce = nonce;
    
    Ok(())
}

/// Handle Scenario A: NFT returning to Solana (origin PDA exists)
fn handle_returning_nft(
    ctx: &Context<OnCall>,
    token_id: u64,
    uri: &str,
    origin_chain: u64,
    sender: &[u8; 20],
    nonce: u64,
    _nft_origin_bump: u8,
) -> Result<()> {
    // Load and deserialize the existing NFT Origin account with enhanced validation
    let nft_origin_data = ctx.accounts.nft_origin.try_borrow_data()
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Validate account data length before deserialization
    require!(
        nft_origin_data.len() >= 8 + NftOrigin::INIT_SPACE,
        UniversalNftError::InvalidMessage
    );
    
    let nft_origin = NftOrigin::try_from_slice(&nft_origin_data)
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    let collection = &ctx.accounts.collection;
    
    // Enhanced validation for the origin PDA
    nft_origin.validate_token_id(token_id)?;
    
    // Validate collection reference
    require_keys_eq!(
        nft_origin.collection,
        collection.key(),
        UniversalNftError::InvalidMessage
    );
    
    // Preserve original metadata URI with validation, otherwise use new URI
    let metadata_uri = if !nft_origin.metadata_uri.is_empty() && 
                          nft_origin.metadata_uri.len() <= 200 {
        nft_origin.metadata_uri.clone()
    } else {
        uri.to_string()
    };
    
    // Store the original mint for the event
    let original_mint = nft_origin.original_mint;
    
    // Create new mint for the returning NFT with enhanced metadata
    mint_nft_with_metadata(
        ctx,
        &metadata_uri,
        format!("Universal NFT #{}", token_id),
        collection.symbol.clone(),
        Some(original_mint), // Pass original mint for reference
    )?;
    
    // Emit event for returning NFT
    emit!(crate::NftReturningToSolana {
        token_id,
        original_mint,
        new_mint: ctx.accounts.nft_mint.key(),
        metadata_preserved: !metadata_uri.is_empty(),
    });
    
    emit!(crate::TokenTransferReceived {
        collection: collection.key(),
        token_id,
        recipient: ctx.accounts.recipient.key(),
        uri: metadata_uri,
        original_sender: sender.to_vec(),
        nonce,
        origin_chain: Some(origin_chain),
        original_mint: Some(original_mint),
        is_returning: true,
    });
    
    Ok(())
}

/// Handle Scenario B: NFT arriving on Solana for the first time
fn handle_new_nft_arrival(
    ctx: &Context<OnCall>,
    token_id: u64,
    uri: &str,
    origin_chain: u64,
    sender: &[u8; 20],
    nonce: u64,
    nft_origin_bump: u8,
) -> Result<()> {
    let collection = &ctx.accounts.collection;
    let clock = Clock::get()?;
    
    // Validate that the NFT Origin account is indeed uninitialized
    require!(
        ctx.accounts.nft_origin.data_is_empty() || ctx.accounts.nft_origin.owner != &crate::ID,
        UniversalNftError::InvalidMessage
    );
    
    // Enhanced NFT Origin account creation with proper rent calculation
    let rent = Rent::get()?;
    let space = 8 + NftOrigin::INIT_SPACE; // Account discriminator + data
    let lamports = rent.minimum_balance(space);
    
    // Validate sufficient funds for account creation
    require!(
        ctx.accounts.payer.lamports() >= lamports,
        UniversalNftError::InsufficientGasAmount
    );
    
    // Create the NFT Origin account with enhanced error handling
    anchor_lang::solana_program::program::invoke_signed(
        &anchor_lang::solana_program::system_instruction::create_account(
            ctx.accounts.payer.key,
            ctx.accounts.nft_origin.key,
            lamports,
            space as u64,
            &crate::ID,
        ),
        &[
            ctx.accounts.payer.to_account_info(),
            ctx.accounts.nft_origin.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
        ],
        &[&[
            b"nft_origin",
            &token_id.to_le_bytes(),
            &[nft_origin_bump],
        ]],
    ).map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Initialize new NFT Origin data with enhanced validation
    let nft_origin = NftOrigin {
        original_mint: ctx.accounts.nft_mint.key(), // This will be the first mint on Solana
        token_id,
        collection: collection.key(),
        chain_of_origin: origin_chain,
        created_at: clock.unix_timestamp,
        metadata_uri: uri.to_string(),
        bump: nft_origin_bump,
    };
    
    // Serialize and save the NFT Origin data with proper error handling
    let mut nft_origin_data = ctx.accounts.nft_origin.try_borrow_mut_data()
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Write account discriminator first
    nft_origin_data[0..8].copy_from_slice(&NftOrigin::discriminator());
    
    // Serialize the data
    nft_origin.serialize(&mut &mut nft_origin_data[8..])
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Create mint and metadata for the new NFT
    mint_nft_with_metadata(
        ctx,
        uri,
        format!("Universal NFT #{}", token_id),
        collection.symbol.clone(),
        None, // No original mint for new arrivals
    )?;
    
    // Emit events for new NFT origin creation
    emit!(crate::NftOriginCreated {
        token_id,
        original_mint: ctx.accounts.nft_mint.key(),
        collection: collection.key(),
        origin_chain,
        metadata_uri: uri.to_string(),
    });
    
    emit!(crate::TokenTransferReceived {
        collection: collection.key(),
        token_id,
        recipient: ctx.accounts.recipient.key(),
        uri: uri.to_string(),
        original_sender: sender.to_vec(),
        nonce,
        origin_chain: Some(origin_chain),
        original_mint: Some(ctx.accounts.nft_mint.key()),
        is_returning: false,
    });
    
    Ok(())
}

/// Mint NFT with proper Metaplex metadata
fn mint_nft_with_metadata(
    ctx: &Context<OnCall>,
    uri: &str,
    name: String,
    symbol: String,
    original_mint: Option<Pubkey>,
) -> Result<()> {
    let collection = &ctx.accounts.collection;
    
    // Extract values before mutable borrow
    let collection_authority = collection.authority;
    let collection_name = collection.name.clone();
    let collection_bump = collection.bump;
    
    // Enhanced validation for metadata parameters
    require!(
        !name.is_empty() && name.len() <= 32,
        UniversalNftError::InvalidMessage
    );
    require!(
        !symbol.is_empty() && symbol.len() <= 10,
        UniversalNftError::InvalidMessage
    );
    require!(
        !uri.is_empty() && uri.len() <= 200,
        UniversalNftError::InvalidMessage
    );
    
    // Mint the NFT token with enhanced error handling
    let cpi_ctx = CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        MintTo {
            mint: ctx.accounts.nft_mint.to_account_info(),
            to: ctx.accounts.nft_token_account.to_account_info(),
            authority: ctx.accounts.collection.to_account_info(),
        },
    );
    
    let seeds = &[
        b"collection",
        collection_authority.as_ref(),
        collection_name.as_bytes(),
        &[collection_bump],
    ];
    let signer_seeds = &[&seeds[..]];
    
    mint_to(cpi_ctx.with_signer(signer_seeds), 1)
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Create Metaplex metadata with proper CPI calls
    create_metadata_account_v3(
        ctx,
        &name,
        &symbol,
        uri,
        original_mint,
        signer_seeds,
    )?;
    
    Ok(())
}

/// Create Metaplex metadata account using proper CPI calls
fn create_metadata_account_v3(
    ctx: &Context<OnCall>,
    name: &str,
    symbol: &str,
    uri: &str,
    original_mint: Option<Pubkey>,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    // Prepare DataV2 struct for proper Metaplex CPI
    let data_v2 = DataV2 {
        name: name.to_string(),
        symbol: symbol.to_string(),
        uri: uri.to_string(),
        seller_fee_basis_points: 0, // No royalties for cross-chain NFTs
        creators: None, // No specific creators for universal NFTs
        collection: None, // Collection verification handled separately
        uses: None, // No usage restrictions
    };
    
    // Create the metadata account using proper Metaplex instruction
    let create_metadata_instruction = create_metadata_accounts_v3_instruction(
        ctx.accounts.metadata_program.key(),
        ctx.accounts.nft_metadata.key(),
        ctx.accounts.nft_mint.key(),
        ctx.accounts.collection.key(), // mint_authority
        ctx.accounts.payer.key(),
        ctx.accounts.collection.key(), // update_authority
        data_v2,
        true, // is_mutable - allow updates for cross-chain scenarios
        true, // update_authority_is_signer
        None, // collection_details
    )?;
    
    // Execute the CPI call with proper error handling
    invoke_signed(
        &create_metadata_instruction,
        &[
            ctx.accounts.nft_metadata.to_account_info(),
            ctx.accounts.nft_mint.to_account_info(),
            ctx.accounts.collection.to_account_info(),
            ctx.accounts.payer.to_account_info(),
            ctx.accounts.collection.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            ctx.accounts.rent.to_account_info(),
        ],
        signer_seeds,
    ).map_err(|e| {
        msg!("Failed to create metadata account: {:?}", e);
        UniversalNftError::InvalidMessage
    })?;
    
    // If this is a returning NFT, add a note about the original mint
    if let Some(orig_mint) = original_mint {
        msg!("NFT returning to Solana. Original mint: {}", orig_mint);
    }
    
    Ok(())
}

/// Create proper Metaplex CreateMetadataAccountsV3 instruction
fn create_metadata_accounts_v3_instruction(
    metadata_program_id: Pubkey,
    metadata_account: Pubkey,
    mint: Pubkey,
    mint_authority: Pubkey,
    payer: Pubkey,
    update_authority: Pubkey,
    data: DataV2,
    is_mutable: bool,
    update_authority_is_signer: bool,
    collection_details: Option<u64>,
) -> Result<anchor_lang::solana_program::instruction::Instruction> {
    use anchor_lang::solana_program::instruction::{AccountMeta, Instruction};
    
    // Account metas for CreateMetadataAccountsV3
    let accounts = vec![
        AccountMeta::new(metadata_account, false),
        AccountMeta::new_readonly(mint, false),
        AccountMeta::new_readonly(mint_authority, true),
        AccountMeta::new(payer, true),
        AccountMeta::new_readonly(update_authority, update_authority_is_signer),
        AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::rent::ID, false),
    ];
    
    // Serialize instruction data for CreateMetadataAccountsV3
    let mut instruction_data = Vec::new();
    
    // Instruction discriminator for CreateMetadataAccountsV3 (simplified)
    instruction_data.push(33); // CreateMetadataAccountsV3 discriminator
    
    // Serialize DataV2
    data.serialize(&mut instruction_data)
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Add is_mutable flag
    instruction_data.push(if is_mutable { 1 } else { 0 });
    
    // Add update_authority_is_signer flag
    instruction_data.push(if update_authority_is_signer { 1 } else { 0 });
    
    // Add collection_details (optional)
    if let Some(details) = collection_details {
        instruction_data.push(1); // Some
        instruction_data.extend_from_slice(&details.to_le_bytes());
    } else {
        instruction_data.push(0); // None
    }
    
    Ok(Instruction {
        program_id: metadata_program_id,
        accounts,
        data: instruction_data,
    })
}

/// Parse cross-chain message to extract NFT data and origin information
fn parse_cross_chain_message(
    message: &[u8],
    source_chain_id: u64,
) -> Result<(u64, String, Pubkey, u64)> {
    // Try to decode as Borsh first (Solana native)
    if let Ok((token_id, uri, recipient)) = try_decode_borsh_message(message) {
        return Ok((token_id, uri, recipient, source_chain_id));
    }
    
    // Try to decode as ABI (EVM chains)
    if let Ok((token_id, uri, recipient)) = try_decode_abi_message(message) {
        return Ok((token_id, uri, recipient, source_chain_id));
    }
    
    // Try enhanced message format with origin information
    if let Ok((token_id, uri, recipient, origin_chain)) = try_decode_enhanced_message(message) {
        return Ok((token_id, uri, recipient, origin_chain));
    }
    
    Err(UniversalNftError::InvalidMessage.into())
}

/// Try to decode enhanced message format with origin information
fn try_decode_enhanced_message(message: &[u8]) -> Result<(u64, String, Pubkey, u64)> {
    // Enhanced format: [token_id(8), origin_chain(8), uri_len(4), uri(variable), recipient(32)]
    require!(message.len() >= 52, UniversalNftError::InvalidMessage);
    
    let mut offset = 0;
    
    // Extract token_id with validation
    let token_id = u64::from_le_bytes(
        message[offset..offset + 8]
            .try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    );
    
    // Validate token_id is not zero
    require!(token_id > 0, UniversalNftError::InvalidTokenId);
    offset += 8;
    
    // Extract origin_chain with validation
    let origin_chain = u64::from_le_bytes(
        message[offset..offset + 8]
            .try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    );
    
    // Validate origin chain is supported
    require!(
        crate::state::is_supported_chain(origin_chain),
        UniversalNftError::UnsupportedChain
    );
    offset += 8;
    
    // Extract URI length with bounds checking
    let uri_len = u32::from_le_bytes(
        message[offset..offset + 4]
            .try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    ) as usize;
    
    // Validate URI length is reasonable
    require!(
        uri_len > 0 && uri_len <= 200,
        UniversalNftError::InvalidMessage
    );
    offset += 4;
    
    // Validate total message length
    require!(
        message.len() >= offset + uri_len + 32,
        UniversalNftError::InvalidMessage
    );
    
    // Extract and validate URI
    let uri = String::from_utf8(message[offset..offset + uri_len].to_vec())
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Validate URI is not empty and contains valid characters
    require!(
        !uri.is_empty() && uri.chars().all(|c| c.is_ascii() && !c.is_control()),
        UniversalNftError::InvalidMessage
    );
    offset += uri_len;
    
    // Extract recipient (32 bytes for Solana pubkey)
    let recipient_bytes: [u8; 32] = message[offset..offset + 32]
        .try_into()
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    let recipient_pubkey = Pubkey::new_from_array(recipient_bytes);
    
    // Validate recipient is not the default pubkey
    require!(
        recipient_pubkey != Pubkey::default(),
        UniversalNftError::InvalidRecipientAddress
    );
    
    Ok((token_id, uri, recipient_pubkey, origin_chain))
}

/// Try to decode ABI-encoded message from EVM chains
fn try_decode_abi_message(message: &[u8]) -> Result<(u64, String, Pubkey)> {
    // Enhanced ABI decoder with proper validation
    // Expected format: [token_id(8), uri_len(4), uri(variable), recipient(32)]
    require!(message.len() >= 44, UniversalNftError::InvalidMessage);
    
    let mut offset = 0;
    
    // Extract token_id with validation
    let token_id = u64::from_le_bytes(
        message[offset..offset + 8]
            .try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    );
    
    // Validate token_id is not zero
    require!(token_id > 0, UniversalNftError::InvalidTokenId);
    offset += 8;
    
    // Extract URI length with bounds checking
    let uri_len = u32::from_le_bytes(
        message[offset..offset + 4]
            .try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    ) as usize;
    
    // Validate URI length is reasonable
    require!(
        uri_len > 0 && uri_len <= 200,
        UniversalNftError::InvalidMessage
    );
    offset += 4;
    
    // Validate total message length
    require!(
        message.len() >= offset + uri_len + 32,
        UniversalNftError::InvalidMessage
    );
    
    // Extract and validate URI
    let uri = String::from_utf8(message[offset..offset + uri_len].to_vec())
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Validate URI format for ABI messages
    require!(
        !uri.is_empty() && uri.starts_with("http") && uri.len() <= 200,
        UniversalNftError::InvalidMessage
    );
    offset += uri_len;
    
    // Extract recipient (32 bytes for Solana pubkey)
    let recipient_bytes: [u8; 32] = message[offset..offset + 32]
        .try_into()
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    let recipient_pubkey = Pubkey::new_from_array(recipient_bytes);
    
    // Validate recipient is not the default pubkey
    require!(
        recipient_pubkey != Pubkey::default(),
        UniversalNftError::InvalidRecipientAddress
    );
    
    Ok((token_id, uri, recipient_pubkey))
}

/// Try to decode Borsh-encoded message (Solana native)
fn try_decode_borsh_message(message: &[u8]) -> Result<(u64, String, Pubkey)> {
    // Enhanced Borsh decoding with validation
    require!(message.len() >= 16, UniversalNftError::InvalidMessage); // Minimum size check
    
    let cross_chain_message = CrossChainMessage::try_from_slice(message)
        .map_err(|_| UniversalNftError::InvalidMessage)?;
    
    // Validate token_id
    require!(
        cross_chain_message.token_id > 0,
        UniversalNftError::InvalidTokenId
    );
    
    // Validate URI
    require!(
        !cross_chain_message.uri.is_empty() && cross_chain_message.uri.len() <= 200,
        UniversalNftError::InvalidMessage
    );
    
    // Validate and convert recipient address
    let recipient_pubkey = validate_solana_address(&cross_chain_message.recipient)?;
    
    // Additional validation for recipient
    require!(
        recipient_pubkey != Pubkey::default(),
        UniversalNftError::InvalidRecipientAddress
    );
    
    Ok((cross_chain_message.token_id, cross_chain_message.uri, recipient_pubkey))
}

/// Helper function to extract token ID from message for PDA derivation
fn extract_token_id_from_message(message: &[u8]) -> Result<u64> {
    // Enhanced validation for token ID extraction
    require!(message.len() >= 8, UniversalNftError::InvalidMessage);
    
    // Token ID is always the first 8 bytes in all message formats
    let token_id = u64::from_le_bytes(
        message[0..8]
            .try_into()
            .map_err(|_| UniversalNftError::InvalidMessage)?
    );
    
    // Validate token ID is not zero
    require!(token_id > 0, UniversalNftError::InvalidTokenId);
    
    // Validate token ID is within reasonable bounds (prevent overflow attacks)
    require!(
        token_id <= u64::MAX / 2, // Reasonable upper bound
        UniversalNftError::InvalidTokenId
    );
    
    Ok(token_id)
}


#[derive(Accounts)]
pub struct OnCall<'info> {
    #[account(
        mut,
        seeds = [b"collection", collection.authority.as_ref(), collection.name.as_bytes()],
        bump = collection.bump
    )]
    pub collection: Account<'info, Collection>,
    
    pub collection_mint: Account<'info, Mint>,
    
    /// CHECK: Gateway program that calls this function
    #[account(address = ZETACHAIN_GATEWAY_PROGRAM_ID)]
    pub gateway: UncheckedAccount<'info>,
    
    /// CHECK: Gateway PDA account
    pub gateway_pda: UncheckedAccount<'info>,
    
    /// CHECK: NFT Origin PDA - validated in instruction
    #[account(mut)]
    pub nft_origin: UncheckedAccount<'info>,
    
    #[account(
        init,
        payer = payer,
        mint::decimals = 0,
        mint::authority = collection,
        mint::freeze_authority = collection,
    )]
    pub nft_mint: Account<'info, Mint>,
    
    #[account(
        init,
        payer = payer,
        associated_token::mint = nft_mint,
        associated_token::authority = recipient,
    )]
    pub nft_token_account: Account<'info, TokenAccount>,
    
    /// CHECK: NFT recipient account - validated in instruction
    pub recipient: UncheckedAccount<'info>,
    
    /// CHECK: Metadata account for the NFT - derived from mint
    #[account(
        mut,
        seeds = [
            b"metadata",
            TOKEN_METADATA_PROGRAM_ID.as_ref(),
            nft_mint.key().as_ref(),
        ],
        bump,
        seeds::program = TOKEN_METADATA_PROGRAM_ID
    )]
    pub nft_metadata: UncheckedAccount<'info>,
    
    #[account(mut)]
    pub payer: Signer<'info>,
    
    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    /// CHECK: mpl-token-metadata program
    #[account(address = TOKEN_METADATA_PROGRAM_ID)]
    pub metadata_program: UncheckedAccount<'info>,
}
